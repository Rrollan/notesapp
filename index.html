<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Liquid Glass</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --text-primary: #000000;
            --text-secondary: rgba(0, 0, 0, 0.6);
            --accent: #007AFF;
            
            /* --- НАСТРОЙКИ СТЕКЛА (VISION OS STYLE) --- */
            /* Прозрачность ниже, размытие выше */
            --glass-bg: rgba(255, 255, 255, 0.45); 
            --glass-blur: blur(40px) saturate(150%);
            /* Граница: белая, полупрозрачная */
            --glass-border: 1px solid rgba(255, 255, 255, 0.6);
            /* Тени: внешняя мягкая + внутренняя белая (блик) */
            --glass-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.9),
                inset 0 0 20px rgba(255, 255, 255, 0.2); 
            
            --radius-l: 32px;
            --radius-m: 20px;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            /* Базовый фон не чисто белый, а чуть серый, чтобы стекло выделялось */
            background-color: #f2f2f7; 
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
        }

        /* --- 1. ЯРКИЙ ЖИВОЙ ФОН --- */
        .mesh-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2;
            overflow: hidden;
            background: #fff; /* Подложка */
        }
        
        /* ГРАДИЕНТНЫЕ ПЯТНА (ярче, чтобы пробивать стекло) */
        .blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px); /* Сильное размытие */
            opacity: 0.8;
            will-change: transform;
            animation: float 20s infinite ease-in-out alternate;
        }
        
        /* Цвета как в заставках iOS */
        .b1 { 
            top: -10%; left: -10%; width: 60vw; height: 60vw; 
            background: radial-gradient(circle, #a18cd1 0%, #fbc2eb 100%); /* Purple-Pink */
            animation-duration: 25s;
        } 
        .b2 { 
            bottom: -10%; right: -10%; width: 50vw; height: 50vw; 
            background: radial-gradient(circle, #8fd3f4 0%, #84fab0 100%); /* Blue-Green */
            animation-duration: 30s; 
            animation-direction: alternate-reverse;
        } 
        .b3 { 
            top: 40%; left: 40%; width: 40vw; height: 40vw; 
            background: radial-gradient(circle, #f6d365 0%, #fda085 100%); /* Orange-Yellow */
            opacity: 0.6;
            animation-duration: 22s;
        } 

        @keyframes float {
            0% { transform: translate(0, 0) scale(1) rotate(0deg); }
            50% { transform: translate(30px, 20px) scale(1.1) rotate(10deg); }
            100% { transform: translate(-20px, 40px) scale(0.95) rotate(-5deg); }
        }

        /* --- 2. СТЕКЛЯННЫЙ КЛАСС --- */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur); /* Для Safari */
            border: var(--glass-border);
            box-shadow: var(--glass-shadow);
            border-radius: var(--radius-l);
        }

        /* --- SIDEBAR --- */
        #sidebar {
            position: fixed; top: 20px; left: 20px; bottom: 20px;
            width: 260px;
            z-index: 2000;
            display: flex; flex-direction: column;
            transition: 0.2s;
        }
        
        .sidebar-header {
            padding: 30px 24px 10px; font-weight: 800; font-size: 1.5rem; letter-spacing: -1px;
            background: linear-gradient(45deg, #333, #000); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .sidebar-hint { font-size: 0.75rem; color: var(--text-secondary); padding: 0 24px 20px; }
        
        .space-list { flex-grow: 1; padding: 10px 15px; overflow-y: auto; }
        .space-item {
            padding: 12px 16px; margin-bottom: 8px; border-radius: 16px; 
            cursor: pointer; display: flex; justify-content: space-between; 
            font-weight: 500; transition: 0.2s; color: #444;
        }
        .space-item:hover { background: rgba(255,255,255,0.4); color: #000; }
        .space-item.active { 
            background: rgba(255,255,255,0.7); color: #000; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); font-weight: 600;
        }
        
        .add-space-btn {
            margin: 10px 20px 20px; padding: 14px; border-radius: 16px;
            background: rgba(255,255,255,0.3); border: 1px solid rgba(255,255,255,0.5);
            color: var(--accent); font-weight: 600; cursor: pointer; transition: 0.2s;
        }
        .add-space-btn:hover { background: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }

        .backup-section { padding: 20px; display: flex; flex-direction: column; gap: 8px; }
        .backup-btn {
            background: transparent; border: 1px solid rgba(0,0,0,0.1); padding: 10px;
            border-radius: 12px; cursor: pointer; font-size: 0.8rem; font-weight: 500;
        }
        .backup-btn:hover { background: rgba(255,255,255,0.5); }

        /* --- TOOLBAR (FLOATING ISLAND) --- */
        #ui-layer {
            position: fixed; top: 20px; left: 300px; z-index: 1000;
            display: flex; gap: 15px; pointer-events: none;
        }
        .toolbar {
            /* Остров */
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(30px);
            padding: 8px; border-radius: 50px; /* Полностью круглый */
            border: 1px solid rgba(255,255,255,0.8);
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            display: flex; gap: 5px; pointer-events: auto;
        }
        .btn {
            background: transparent; border: none; padding: 10px 20px;
            border-radius: 40px; cursor: pointer; font-weight: 600; font-size: 0.9rem;
            color: #333; transition: 0.2s;
        }
        .btn:hover { background: rgba(0,0,0,0.05); }
        .btn.primary { background: #000; color: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .btn.primary:hover { transform: scale(1.05); }
        .btn.danger { color: #ff3b30; }
        .btn.danger:hover { background: rgba(255, 59, 48, 0.1); }

        /* --- CANVAS --- */
        #viewport { position: absolute; width: 100%; height: 100%; overflow: hidden; cursor: grab; }
        #viewport:active { cursor: grabbing; }
        #world { position: absolute; transform-origin: 0 0; }
        #connections-layer { position: absolute; pointer-events: none; top: -50000px; left: -50000px; }
        path.connection { fill: none; stroke: rgba(0,0,0,0.2); stroke-width: 2px; transition: 0.2s; }
        path.connection:hover { stroke: var(--accent); stroke-width: 3px; cursor: pointer; }

        /* --- NODES (VISION PRO CARDS) --- */
        .node {
            position: absolute; min-width: 260px;
            /* Стекло для карточек */
            background: rgba(255, 255, 255, 0.55);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 20px 50px -10px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
            border-radius: var(--radius-m);
            display: flex; flex-direction: column; z-index: 1; 
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .node:hover { 
            box-shadow: 0 30px 60px -10px rgba(0,0,0,0.2), inset 0 1px 0 #fff; 
            z-index: 10;
        }
        .node.selected {
            border: 2px solid var(--accent);
            box-shadow: 0 0 0 4px rgba(0, 122, 255, 0.2);
        }

        .node-header {
            padding: 16px 20px; font-weight: 600;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            background: rgba(255,255,255,0.2); /* Легкое выделение шапки */
            border-radius: var(--radius-m) var(--radius-m) 0 0;
            cursor: grab; display: flex; justify-content: space-between;
        }
        .header-text { outline: none; border-bottom: 1px solid transparent; }
        .header-text:focus { border-color: var(--accent); }

        .node-content {
            padding: 20px; font-size: 1rem; line-height: 1.5; outline: none; flex-grow: 1; cursor: text;
        }
        
        .content-img { padding: 0; overflow: hidden; border-radius: 0 0 var(--radius-m) var(--radius-m); background: rgba(0,0,0,0.03); }
        .content-img img { width: 100%; display: block; pointer-events: none; }
        
        /* HANDLES & RESIZERS */
        .resizer { position: absolute; right: 0; bottom: 0; width: 25px; height: 25px; cursor: se-resize; opacity: 0; }
        .resizer::after { content: ''; position: absolute; right: 8px; bottom: 8px; width: 6px; height: 6px; border-right: 2px solid #aaa; border-bottom: 2px solid #aaa; border-radius: 1px; }
        .node:hover .resizer { opacity: 1; }

        .handle {
            position: absolute; width: 16px; height: 16px; background: #fff; border: 2px solid #ccc;
            border-radius: 50%; z-index: 20; opacity: 0; cursor: crosshair; transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .node:hover .handle { opacity: 1; }
        .handle:hover { transform: scale(1.3); border-color: var(--accent); background: var(--accent); }
        .h-top { top: -8px; left: 50%; transform: translateX(-50%); }
        .h-right { right: -8px; top: 50%; transform: translateY(-50%); }
        .h-bottom { bottom: -8px; left: 50%; transform: translateX(-50%); }
        .h-left { left: -8px; top: 50%; transform: translateY(-50%); }

        /* --- STYLES MENU --- */
        #style-menu {
            position: absolute; display: none; z-index: 2000;
            background: rgba(255,255,255,0.8); backdrop-filter: blur(20px);
            padding: 8px 12px; border-radius: 40px; border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 10px 40px rgba(0,0,0,0.2); gap: 10px; transform: translate(-50%, -140%);
        }
        .color-dot { width: 24px; height: 24px; border-radius: 50%; cursor: pointer; transition: 0.2s; border: 2px solid transparent;}
        .color-dot:hover { transform: scale(1.2); border-color: rgba(0,0,0,0.2); }

        /* --- MODAL --- */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 5000;
            background: rgba(255,255,255,0.4); backdrop-filter: blur(10px);
            display: none; justify-content: center; align-items: center;
        }
        #modal-box {
            background: #fff; padding: 30px; border-radius: 30px; width: 350px;
            box-shadow: 0 30px 80px rgba(0,0,0,0.2); border: 1px solid #eee;
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop { from{transform:scale(0.8); opacity:0} to{transform:scale(1); opacity:1}}
        .modal-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 12px; margin-top: 10px; font-size: 1rem; outline: none; box-sizing: border-box;}
        .modal-input:focus { border-color: var(--accent); }
        .modal-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        
        #hidden-file-input, #backup-file-input { display: none; }
    </style>
</head>
<body>

    <!-- 1. ФОН: ГРАДИЕНТНЫЕ ПЯТНА -->
    <div class="mesh-bg">
        <div class="blob b1"></div>
        <div class="blob b2"></div>
        <div class="blob b3"></div>
    </div>

    <input type="file" id="hidden-file-input">
    <input type="file" id="backup-file-input" accept=".json">

    <!-- SIDEBAR -->
    <div id="sidebar" class="glass-panel">
        <div class="sidebar-header">Glass Space</div>
        <div class="sidebar-hint">Double click to rename</div>
        <div class="space-list" id="space-list"></div>
        <button class="add-space-btn" onclick="openCreateSpaceModal()">+ New Space</button>
        <div class="backup-section">
            <button class="backup-btn" onclick="downloadBackup()">↓ Save Backup</button>
            <button class="backup-btn" onclick="triggerRestore()">↑ Restore</button>
        </div>
    </div>

    <!-- TOOLBAR -->
    <div id="ui-layer">
        <div class="toolbar">
            <button class="btn primary" onclick="spawnNode('text')">Text</button>
            <button class="btn" onclick="openMediaModal('image')">Image</button>
            <button class="btn" onclick="openMediaModal('video')">Video</button>
            <button class="btn" onclick="spawnNode('task')">Tasks</button>
            <div style="width:1px; background:rgba(0,0,0,0.1); margin: 0 5px;"></div>
            <button class="btn danger" onclick="confirmClearCanvas()">Clear</button>
        </div>
    </div>

    <!-- CONTEXT MENU -->
    <div id="style-menu">
        <div class="color-dot" style="background:#fff; border:1px solid #ddd;" onclick="applyStyle('color', 'default')"></div>
        <div class="color-dot" style="background:#FF3B30;" onclick="applyStyle('color', 'red')"></div>
        <div class="color-dot" style="background:#34C759;" onclick="applyStyle('color', 'green')"></div>
        <div class="color-dot" style="background:#007AFF;" onclick="applyStyle('color', 'blue')"></div>
        <div class="color-dot" style="background:#FFCC00;" onclick="applyStyle('color', 'yellow')"></div>
        <button class="btn" style="padding: 5px 10px; font-size: 12px;" onclick="deleteSelectedNode()">Delete</button>
    </div>

    <!-- MODAL -->
    <div id="modal-overlay">
        <div id="modal-box">
            <h2 id="modal-title" style="margin:0;">Title</h2>
            <div id="modal-body"></div>
            <div class="modal-btns">
                <button class="btn" onclick="closeModal()">Cancel</button>
                <button class="btn primary" id="modal-confirm">Confirm</button>
            </div>
        </div>
    </div>

    <div id="viewport">
        <div id="world">
            <svg id="connections-layer" width="100000" height="100000" xmlns="http://www.w3.org/2000/svg">
                <defs><marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#aaa"/></marker></defs>
            </svg>
        </div>
    </div>

<script>
    // --- ПАРАЛЛАКС ДЛЯ ВАУ-ЭФФЕКТА ---
    document.addEventListener('mousemove', (e) => {
        const x = (e.clientX / window.innerWidth - 0.5) * 50;
        const y = (e.clientY / window.innerHeight - 0.5) * 50;
        document.querySelectorAll('.blob').forEach((b, i) => {
            const speed = i + 1;
            b.style.transform = `translate(${x * speed}px, ${y * speed}px)`;
        });
    });

    // --- LOGIC (Simplified for stability) ---
    let spaces = JSON.parse(localStorage.getItem('ob_spaces')) || ['Main'];
    let currentSpace = localStorage.getItem('ob_currentSpace') || 'Main';
    let nodes = [], edges = [];
    let state = { x: 0, y: 0, scale: 1 };
    let idCounter = 1;
    let selectedId = null;
    let drag = null;
    let connStart = null;
    let tempLine = null;

    const viewport = document.getElementById('viewport');
    const world = document.getElementById('world');
    const svg = document.getElementById('connections-layer');

    function init() {
        loadSpace(currentSpace);
        renderSpaces();
        updateTransform();
    }

    function renderSpaces() {
        const l = document.getElementById('space-list'); l.innerHTML = '';
        spaces.forEach(s => {
            const d = document.createElement('div');
            d.className = `space-item ${s===currentSpace?'active':''}`;
            d.innerText = s;
            d.onclick = () => { if(s!==currentSpace) { saveSpace(); currentSpace=s; localStorage.setItem('ob_currentSpace', s); loadSpace(s); renderSpaces(); }};
            l.appendChild(d);
        });
    }

    function saveSpace() { localStorage.setItem('ob_'+currentSpace, JSON.stringify({nodes, edges, idCounter, state})); }
    function loadSpace(n) {
        const d = JSON.parse(localStorage.getItem('ob_'+n));
        if(d) { nodes=d.nodes; edges=d.edges; idCounter=d.idCounter; state=d.state||{x:0,y:0,scale:1}; }
        else { nodes=[]; edges=[]; idCounter=1; }
        render();
    }

    function spawnNode(type) {
        const id = 'n' + (idCounter++);
        const cx = (-state.x + window.innerWidth/2)/state.scale - 130;
        const cy = (-state.y + window.innerHeight/2)/state.scale - 50;
        let content = 'Double click to edit';
        if(type==='task') content = `<div style="display:flex; gap:10px;"><input type="checkbox"><input type="text" value="Task 1" style="background:transparent; border:none; width:100%;"></div>`;
        nodes.push({ id, x: cx, y: cy, w: 260, type, title: 'Card', content, color: 'default' });
        render(); saveSpace();
    }

    function render() {
        document.querySelectorAll('.node').forEach(e=>e.remove());
        const oldDefs = svg.querySelector('defs'); svg.innerHTML = ''; svg.appendChild(oldDefs);
        
        nodes.forEach(n => {
            const el = document.createElement('div');
            el.className = `node ${n.id===selectedId?'selected':''}`;
            el.style.left = n.x+'px'; el.style.top = n.y+'px'; el.style.width = n.w+'px';
            if(n.color !== 'default') el.style.background = n.color === 'blue' ? 'rgba(0,122,255,0.1)' : n.color==='red'?'rgba(255,59,48,0.1)':'rgba(52,199,89,0.1)';
            
            let inn = '';
            if(n.type === 'image') inn = `<div class="content-img">${n.content}</div>`;
            else inn = `<div class="node-content" ${n.type==='text'?'contenteditable="true"':''}>${n.content}</div>`;

            el.innerHTML = `<div class="node-header"><span class="header-text">${n.title}</span></div>${inn}
                            <div class="handle h-top" data-s="top"></div><div class="handle h-right" data-s="right"></div>
                            <div class="handle h-bottom" data-s="bottom"></div><div class="handle h-left" data-s="left"></div>
                            <div class="resizer"></div>`;
            
            el.querySelector('.header-text').addEventListener('dblclick', e => { e.target.contentEditable=true; e.target.focus(); });
            el.querySelector('.header-text').addEventListener('blur', e => { e.target.contentEditable=false; n.title = e.target.innerText; saveSpace(); });
            if(n.type==='text') el.querySelector('.node-content').addEventListener('input', e => { n.content = e.target.innerHTML; saveSpace(); });

            el.onmousedown = e => { 
                if(e.target.classList.contains('handle')) return;
                e.stopPropagation(); selectedId=n.id; render(); 
                const startX = (e.clientX - state.x)/state.scale - n.x;
                const startY = (e.clientY - state.y)/state.scale - n.y;
                if(e.target.classList.contains('resizer')) {
                     drag = { type:'resize', n, sx: e.clientX, sw: n.w };
                } else if(!e.target.isContentEditable) {
                     drag = { type:'move', n, offX: startX, offY: startY };
                }
                showMenu(n);
            };

            // Handles
            el.querySelectorAll('.handle').forEach(h => {
                h.onmousedown = e => {
                    e.stopPropagation(); e.preventDefault();
                    connStart = { id: n.id, side: h.dataset.s, x: n.x, y: n.y, w: n.w, h: el.offsetHeight };
                    tempLine = document.createElementNS('http://www.w3.org/2000/svg','path');
                    tempLine.setAttribute('stroke', '#007AFF'); tempLine.setAttribute('stroke-width','2'); tempLine.setAttribute('fill','none');
                    svg.appendChild(tempLine);
                }
            });

            world.appendChild(el);
        });

        edges.forEach(e => drawEdge(e));
    }

    function drawEdge(e) {
        const n1 = nodes.find(n=>n.id===e.f);
        const n2 = nodes.find(n=>n.id===e.t);
        if(!n1 || !n2) return;
        const el1 = document.querySelectorAll('.node')[nodes.indexOf(n1)];
        const el2 = document.querySelectorAll('.node')[nodes.indexOf(n2)];
        if(!el1 || !el2) return;
        
        const p1 = getPort(n1, el1, e.fs);
        const p2 = getPort(n2, el2, e.ts);
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('class', 'connection');
        path.setAttribute('d', `M ${p1.x} ${p1.y} C ${p1.x + (e.fs=='right'?50:e.fs=='left'?-50:0)} ${p1.y+(e.fs=='bottom'?50:e.fs=='top'?-50:0)}, ${p2.x + (e.ts=='right'?50:e.ts=='left'?-50:0)} ${p2.y+(e.ts=='bottom'?50:e.ts=='top'?-50:0)}, ${p2.x} ${p2.y}`);
        path.oncontextmenu = (ev) => { ev.preventDefault(); edges = edges.filter(x => x !== e); render(); saveSpace(); };
        svg.appendChild(path);
    }

    function getPort(n, el, side) {
        const h = el.offsetHeight;
        if(side==='top') return {x: n.x+n.w/2, y: n.y};
        if(side==='bottom') return {x: n.x+n.w/2, y: n.y+h};
        if(side==='left') return {x: n.x, y: n.y+h/2};
        return {x: n.x+n.w, y: n.y+h/2};
    }

    window.onmousemove = e => {
        const mx = (e.clientX - state.x)/state.scale;
        const my = (e.clientY - state.y)/state.scale;
        if(drag) {
            if(drag.type === 'move') { drag.n.x = mx - drag.offX; drag.n.y = my - drag.offY; }
            if(drag.type === 'resize') { drag.n.w = Math.max(200, drag.sw + (e.clientX - drag.sx)/state.scale); }
            render();
        }
        if(connStart) {
            let sx = connStart.x; let sy = connStart.y;
            if(connStart.side=='right') { sx+=connStart.w; sy+=connStart.h/2; }
            else if(connStart.side=='bottom') { sx+=connStart.w/2; sy+=connStart.h; }
            else if(connStart.side=='left') { sy+=connStart.h/2; }
            else { sx+=connStart.w/2; }
            tempLine.setAttribute('d', `M ${sx} ${sy} L ${mx} ${my}`);
        }
        if(e.buttons === 1 && e.target === viewport) {
            state.x += e.movementX; state.y += e.movementY; updateTransform();
        }
    };

    window.onmouseup = e => {
        if(drag) saveSpace(); drag = null;
        if(connStart) {
            tempLine.remove();
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if(el && el.classList.contains('handle')) {
                const targetNode = nodes.find(n => Math.abs(n.x - ((e.clientX - state.x)/state.scale)) < n.w + 100 ); // Simple approximation
                // better to find via DOM
                const domNode = el.closest('.node'); 
                const tn = nodes[Array.from(world.children).indexOf(domNode)];
                if(tn && tn.id !== connStart.id) {
                    edges.push({ f: connStart.id, fs: connStart.side, t: tn.id, ts: el.dataset.s });
                    render(); saveSpace();
                }
            }
            connStart = null;
        }
    };

    window.onwheel = e => { e.preventDefault(); state.scale += e.deltaY * -0.001; state.scale = Math.min(Math.max(0.2, state.scale), 3); updateTransform(); };
    function updateTransform() { world.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`; }

    function showMenu(n) {
        const m = document.getElementById('style-menu');
        m.style.display = 'flex';
        const rect = document.querySelectorAll('.node')[nodes.indexOf(n)].getBoundingClientRect();
        m.style.left = (rect.left + rect.width/2) + 'px';
        m.style.top = (rect.top - 10) + 'px';
    }
    document.addEventListener('mousedown', e => { if(!e.target.closest('.node') && !e.target.closest('#style-menu')) { selectedId=null; document.getElementById('style-menu').style.display='none'; render(); } });

    function applyStyle(p, v) { 
        if(selectedId) { nodes.find(n=>n.id===selectedId)[p] = v; render(); saveSpace(); } 
    }
    function deleteSelectedNode() {
        if(selectedId) { nodes=nodes.filter(n=>n.id!==selectedId); edges=edges.filter(e=>e.f!==selectedId && e.t!==selectedId); selectedId=null; render(); saveSpace(); }
    }
    
    // --- Utils for Modals ---
    const modal = document.getElementById('modal-overlay');
    function openMediaModal(type) {
        modal.style.display = 'flex'; document.getElementById('modal-title').innerText = type==='image'?'Add Image':'Add Video';
        document.getElementById('modal-body').innerHTML = `<input class="modal-input" placeholder="Paste URL..."><br><br><button class="btn" onclick="document.getElementById('hidden-file-input').click()">Or Upload File</button>`;
        document.getElementById('modal-confirm').onclick = () => {
            const val = document.querySelector('.modal-input').value;
            if(val) {
                const c = (-state.x + window.innerWidth/2)/state.scale;
                const cy = (-state.y + window.innerHeight/2)/state.scale;
                const content = type==='image' ? `<img src="${val}">` : `<iframe src="${val}" style="width:100%; height:200px; border:none;"></iframe>`;
                nodes.push({id:'n'+(idCounter++), x:c-130, y:cy-100, w:300, type, title: type, content, color:'default'});
                render(); saveSpace(); closeModal();
            }
        };
        const fi = document.getElementById('hidden-file-input');
        fi.onchange = (e) => {
            const f = e.target.files[0];
            const r = new FileReader();
            r.onload = (ev) => {
                const c = (-state.x + window.innerWidth/2)/state.scale;
                const cy = (-state.y + window.innerHeight/2)/state.scale;
                const content = type==='image' ? `<img src="${ev.target.result}">` : `<video src="${ev.target.result}" controls style="width:100%"></video>`;
                nodes.push({id:'n'+(idCounter++), x:c-130, y:cy-100, w:300, type, title: type, content, color:'default'});
                render(); saveSpace(); closeModal();
            };
            r.readAsDataURL(f);
        }
    }
    function closeModal() { modal.style.display = 'none'; }
    function openCreateSpaceModal() { 
        const n = prompt("Space Name:"); 
        if(n) { spaces.push(n); saveSpace(); localStorage.setItem('ob_spaces', JSON.stringify(spaces)); renderSpaces(); } 
    }
    function confirmClearCanvas() { if(confirm("Clear All?")) { nodes=[]; edges=[]; render(); saveSpace(); } }
    
    init();
</script>
</body>
</html>
