<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Liquid Canvas: Miro Style</title>
    <!-- Шрифт Inter для чистоты интерфейса -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #F4F5F7;
            --dot-color: #C5C6C9;
            --accent: #007AFF;
            --accent-danger: #FF3B30;
            --sidebar-width: 260px;
            --glass-border: rgba(255, 255, 255, 0.6);
            --glass-bg: rgba(255, 255, 255, 0.65);
            --glass-shadow: 0 12px 40px rgba(0, 0, 0, 0.08);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            color: #1d1d1f;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        /* --- 1. БЕСКОНЕЧНЫЙ ХОЛСТ С ТОЧКАМИ --- */
        #viewport {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden; cursor: grab;
            z-index: 0;
        }
        #viewport:active { cursor: grabbing; }

        #world {
            position: absolute; top: 0; left: 0;
            width: 0; height: 0; /* Размеры не важны, важен transform */
            transform-origin: 0 0;
            will-change: transform;
        }

        /* Оптимизированная сетка - применяется к псевдоэлементу фона, чтобы не дергалась */
        .grid-background {
            position: fixed; top: -50000px; left: -50000px;
            width: 100000px; height: 100000px;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle, var(--dot-color) 1.5px, transparent 1.5px);
            background-size: 24px 24px; /* Размер клетки */
            z-index: -1;
            pointer-events: none;
        }

        /* --- 2. ЭФФЕКТ LIQUID GLASS (ИСПРАВЛЕННЫЙ) --- */
        .liquid-glass {
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            position: relative;
            z-index: 10;
        }
        
        /* Добавляем "шум" и легкое искажение только на фон, чтобы текст был четким */
        .liquid-glass::before {
            content: ''; position: absolute; inset: 0; 
            border-radius: inherit; pointer-events: none; z-index: -1;
            opacity: 0.4;
            /* Более мягкий фильтр */
            filter: url(#liquid-filter); 
        }

        /* --- 3. UI: САЙДБАР И ТУЛБАР --- */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1000;
        }

        /* Сайдбар */
        #sidebar {
            position: absolute; top: 20px; left: 20px; bottom: 20px;
            width: var(--sidebar-width);
            border-radius: 24px;
            display: flex; flex-direction: column;
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.3s;
        }
        /* Сворачивание сайдбара влево */
        #sidebar.collapsed { transform: translateX(calc(-100% - 30px)); opacity: 0.5; }
        
        /* Триггер зона для показа сайдбара */
        .sidebar-trigger {
            position: absolute; top: 0; left: 0; width: 20px; height: 100%;
            pointer-events: auto; z-index: 1001;
        }
        .sidebar-trigger:hover ~ #ui-layer #sidebar { transform: translateX(0); opacity: 1; }

        .sidebar-header {
            padding: 24px; font-weight: 800; font-size: 1.2rem;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex; justify-content: space-between; align-items: center;
        }
        .space-list { flex: 1; overflow-y: auto; padding: 10px 16px; }
        
        .space-item {
            padding: 10px 14px; margin-bottom: 4px; border-radius: 12px; cursor: pointer;
            font-size: 0.95rem; font-weight: 500; color: #555;
            display: flex; justify-content: space-between; transition: 0.2s;
        }
        .space-item:hover { background: rgba(255,255,255,0.5); color: #000; }
        .space-item.active { background: #fff; color: var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .space-del { opacity: 0; color: var(--accent-danger); font-weight: bold; padding: 0 5px;}
        .space-item:hover .space-del { opacity: 1; }

        .sidebar-footer { padding: 20px; border-top: 1px solid rgba(0,0,0,0.05); }
        .btn-full { width: 100%; padding: 12px; border-radius: 14px; border: 1px dashed #999; background: rgba(255,255,255,0.3); cursor: pointer; font-weight: 600; color: #444; transition: 0.2s; }
        .btn-full:hover { background: #fff; border-color: var(--accent); color: var(--accent); }
        .backup-row { display: flex; gap: 8px; margin-top: 10px; }
        .btn-small { flex: 1; padding: 8px; border-radius: 10px; border: none; background: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.8rem; transition: 0.2s; }
        .btn-small:hover { background: #fff; transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }

        /* Тулбар (вверху) */
        #toolbar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; padding: 6px;
            border-radius: 20px;
            pointer-events: auto;
            transition: transform 0.3s;
        }
        #toolbar:hover { transform: translateX(-50%) translateY(2px); }

        .tool-btn {
            border: none; background: transparent; padding: 10px 16px;
            border-radius: 14px; cursor: pointer; font-weight: 600; font-size: 0.9rem;
            color: #333; transition: 0.2s; display: flex; align-items: center; gap: 6px;
        }
        .tool-btn:hover { background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .tool-btn.primary { background: #fff; color: #000; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .tool-btn.danger { color: var(--accent-danger); }
        .tool-btn.danger:hover { background: #FFF0F0; }

        /* --- 4. НОДЫ (КАРТОЧКИ) --- */
        .node {
            position: absolute; 
            min-width: 240px; 
            border-radius: 20px;
            /* Стекло для самих карточек */
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
            
            display: flex; flex-direction: column;
            transition: box-shadow 0.2s, transform 0.1s;
        }
        .node:hover { box-shadow: 0 15px 40px rgba(0,0,0,0.12); z-index: 100 !important; }
        .node.selected { 
            box-shadow: 0 0 0 2px var(--accent), 0 20px 50px rgba(0,0,0,0.15); 
            z-index: 101 !important; 
        }

        /* Цветовые стили */
        .node.color-yellow { background: rgba(255, 250, 230, 0.9); }
        .node.color-blue { background: rgba(235, 245, 255, 0.9); }
        .node.color-green { background: rgba(235, 255, 240, 0.9); }
        .node.color-red { background: rgba(255, 240, 240, 0.9); }
        
        .node.shape-round { border-radius: 32px; }

        .node-header {
            padding: 14px 20px;
            border-bottom: 1px solid rgba(0,0,0,0.06);
            font-weight: 600; font-size: 0.95rem; cursor: grab;
            display: flex; align-items: center; justify-content: space-between;
        }
        .node-header:active { cursor: grabbing; }
        .node-title { outline: none; min-width: 50px; }
        .node-content {
            padding: 20px; font-size: 1rem; line-height: 1.5; color: #333; outline: none; min-height: 40px; cursor: text;
        }
        
        /* Медиа контент */
        .node-media { padding: 0; border-radius: 0 0 20px 20px; overflow: hidden; display: flex; background: rgba(0,0,0,0.03); }
        .node-media img { width: 100%; height: auto; display: block; }
        .node-media iframe, .node-media video { width: 100%; height: 100%; min-height: 200px; border: none; }

        /* Элементы управления (Handle & Resizer) */
        .resizer { position: absolute; right: 0; bottom: 0; width: 20px; height: 20px; cursor: se-resize; opacity: 0; }
        .node:hover .resizer { opacity: 1; }
        .resizer::after { content: ''; position: absolute; bottom: 6px; right: 6px; width: 6px; height: 6px; border-right: 2px solid #aaa; border-bottom: 2px solid #aaa; }

        .handle {
            position: absolute; width: 12px; height: 12px; background: #fff; border: 2px solid var(--accent); border-radius: 50%;
            z-index: 200; cursor: crosshair; opacity: 0; transition: 0.2s;
        }
        .node:hover .handle { opacity: 1; }
        .handle:hover { transform: scale(1.5); background: var(--accent); }
        .h-top { top: -8px; left: 50%; transform: translateX(-50%); }
        .h-right { right: -8px; top: 50%; transform: translateY(-50%); }
        .h-bottom { bottom: -8px; left: 50%; transform: translateX(-50%); }
        .h-left { left: -8px; top: 50%; transform: translateY(-50%); }

        /* --- 5. ЗАДАЧИ --- */
        .task-row { display: flex; align-items: flex-start; gap: 8px; margin-bottom: 6px; }
        .task-check { 
            width: 18px; height: 18px; border: 2px solid #ccc; border-radius: 6px; 
            cursor: pointer; margin-top: 3px; flex-shrink: 0; transition: 0.2s;
            background: #fff;
        }
        .task-row.done .task-check { background: var(--accent-green); border-color: var(--accent-green); background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10'%3E%3Cpath d='M1 5 L4 8 L9 2' fill='none' stroke='white' stroke-width='2'/%3E%3C/svg%3E"); }
        .task-row.done input { text-decoration: line-through; opacity: 0.6; }
        .task-input { border: none; background: transparent; flex: 1; font-size: 1rem; outline: none; }
        .task-add { color: var(--accent); font-size: 0.85rem; cursor: pointer; padding: 5px 0; font-weight: 500;}

        /* --- 6. SVG СВЯЗИ --- */
        #connections-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; z-index: -1;
        }
        path.connection {
            fill: none; stroke: #C5C6C9; stroke-width: 2px; pointer-events: stroke; transition: stroke 0.2s; stroke-linecap: round;
        }
        path.connection:hover { stroke: var(--accent); stroke-width: 4px; cursor: pointer; }

        /* --- 7. КОНТЕКСТНОЕ МЕНЮ СТИЛЕЙ --- */
        #context-menu {
            position: fixed; display: none; z-index: 2000;
            background: #fff; padding: 6px; border-radius: 50px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            gap: 8px; align-items: center;
        }
        .color-dot { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 1px solid rgba(0,0,0,0.1); transition: transform 0.2s;}
        .color-dot:hover { transform: scale(1.2); }
        .sep { width: 1px; height: 16px; background: #eee; }

        /* --- 8. МОДАЛКИ --- */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.2); backdrop-filter: blur(5px);
            z-index: 5000; display: none; justify-content: center; align-items: center;
        }
        .modal-box {
            background: #fff; padding: 30px; border-radius: 24px; width: 340px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from{ transform: scale(0.9) translateY(20px); opacity:0;} to{transform: scale(1) translateY(0); opacity:1;} }
        .modal-input { width: 100%; padding: 12px; margin: 15px 0; border: 1px solid #ddd; border-radius: 10px; font-size: 1rem; box-sizing: border-box;}
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; }
        
        /* Скрытые инпуты */
        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <!-- SVG ФИЛЬТР: Исправленные параметры для мягкого эффекта -->
    <svg style="display: none;">
      <defs>
        <filter id="liquid-filter" x="0%" y="0%" width="100%" height="100%">
          <feTurbulence type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="1" result="warp" />
          <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="15" in="SourceGraphic" in2="warp" />
        </filter>
      </defs>
    </svg>

    <div class="sidebar-trigger"></div>

    <div id="ui-layer">
        <!-- SIDEBAR -->
        <div id="sidebar" class="liquid-glass">
            <div class="sidebar-header">
                <span>Liquid Canvas</span>
                <span style="font-size:10px; color:#666; font-weight:400;">v2.0</span>
            </div>
            <div class="space-list" id="space-list">
                <!-- Пространства генерируются JS -->
            </div>
            <div class="sidebar-footer">
                <button class="btn-full" onclick="openCreateSpaceModal()">+ New Space</button>
                <div class="backup-row">
                    <button class="btn-small" onclick="downloadBackup()">↓ Save</button>
                    <button class="btn-small" onclick="triggerRestore()">↑ Load</button>
                </div>
            </div>
        </div>

        <!-- TOOLBAR -->
        <div id="toolbar" class="liquid-glass">
            <button class="tool-btn primary" onclick="spawnNode('text')"><span>T</span> Text</button>
            <button class="tool-btn" onclick="openMediaModal('image')">Image</button>
            <button class="tool-btn" onclick="spawnNode('task')">Tasks</button>
            <button class="tool-btn" onclick="spawnNode('link')">Link</button>
            <div style="width:1px; background:rgba(0,0,0,0.1); margin: 0 4px;"></div>
            <button class="tool-btn danger" onclick="confirmClearCanvas()">Clear</button>
        </div>
    </div>

    <!-- CONTEXT MENU (появляется над выделенной нодой) -->
    <div id="context-menu">
        <div class="color-dot" style="background:#fff;" onclick="applyStyle('color', 'default')"></div>
        <div class="color-dot" style="background:#fff9c4;" onclick="applyStyle('color', 'yellow')"></div>
        <div class="color-dot" style="background:#e3f2fd;" onclick="applyStyle('color', 'blue')"></div>
        <div class="color-dot" style="background:#e8f5e9;" onclick="applyStyle('color', 'green')"></div>
        <div class="color-dot" style="background:#ffebee;" onclick="applyStyle('color', 'red')"></div>
        <div class="sep"></div>
        <button class="tool-btn" style="padding:4px 8px; font-size:11px;" onclick="applyStyle('shape', 'round')">Round</button>
        <div class="sep"></div>
        <button class="tool-btn danger" style="padding:4px 8px; font-size:12px;" onclick="deleteSelectedNode()">✕</button>
    </div>

    <!-- MAIN CANVAS -->
    <div id="viewport">
        <div id="world">
             <!-- Фоновая сетка внутри world, чтобы двигалась вместе с зумом, но позиционировалась через JS -->
            <div class="grid-background" id="grid-bg"></div>
            
            <svg id="connections-layer" xmlns="http://www.w3.org/2000/svg">
                <!-- Связи рисуются здесь -->
            </svg>
            <!-- Ноды добавляются сюда -->
        </div>
    </div>

    <!-- MODAL -->
    <div id="modal-overlay">
        <div class="modal-box">
            <h3 id="modal-title" style="margin-top:0;">Title</h3>
            <div id="modal-body"></div>
            <div class="modal-actions">
                <button class="btn-small" onclick="closeModal()">Cancel</button>
                <button id="modal-confirm-btn" class="tool-btn primary">OK</button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input">

    <script>
        // --- CORE STATE ---
        let state = {
            scale: 1,
            panX: window.innerWidth / 2, // Центрируем начало координат
            panY: window.innerHeight / 2,
            isDragging: false,
            startX: 0, startY: 0
        };
        
        let nodes = [];
        let edges = [];
        let idCounter = 1;
        let spaces = JSON.parse(localStorage.getItem('lc_spaces')) || ['Main Board'];
        let currentSpace = localStorage.getItem('lc_currentSpace') || 'Main Board';
        let selectedNodeId = null;

        // Элементы DOM
        const world = document.getElementById('world');
        const viewport = document.getElementById('viewport');
        const svgLayer = document.getElementById('connections-layer');
        const contextMenu = document.getElementById('context-menu');
        const fileInput = document.getElementById('file-input');

        // --- INIT ---
        function init() {
            loadSpace(currentSpace);
            renderSidebar();
            updateTransform();
            
            // Обработчики событий мира
            viewport.addEventListener('mousedown', onPointerDown);
            window.addEventListener('mousemove', onPointerMove);
            window.addEventListener('mouseup', onPointerUp);
            viewport.addEventListener('wheel', onWheel, {passive: false});
            
            // Клавиши
            window.addEventListener('keydown', (e) => {
                if((e.key === 'Delete' || e.key === 'Backspace') && !e.target.closest('input') && !e.target.isContentEditable) deleteSelectedNode();
                if((e.ctrlKey || e.metaKey) && e.key === 'z') undo(); // Простой placeholder для undo
            });
        }

        // --- SPACE MANAGEMENT ---
        function loadSpace(name) {
            currentSpace = name;
            localStorage.setItem('lc_currentSpace', name);
            const data = localStorage.getItem(`lc_data_${name}`);
            if (data) {
                const parsed = JSON.parse(data);
                nodes = parsed.nodes || [];
                edges = parsed.edges || [];
                idCounter = parsed.idCounter || 1;
                // Сохраняем позицию камеры если есть
                if(parsed.view) { state.panX = parsed.view.x; state.panY = parsed.view.y; state.scale = parsed.view.scale; }
            } else {
                nodes = []; edges = []; idCounter = 1;
                // Демо контент
                createNode(0, 0, 'text', 'Welcome', 'Это ваш бесконечный холст.<br>Двигайте колесиком мыши.<br>Зажмите пробел для панорамирования.');
            }
            renderAll();
            renderSidebar();
            updateTransform();
        }

        function saveData() {
            const data = { nodes, edges, idCounter, view: {x: state.panX, y: state.panY, scale: state.scale} };
            localStorage.setItem(`lc_data_${currentSpace}`, JSON.stringify(data));
        }

        // --- RENDERING ---
        function renderAll() {
            // Очистка нод
            document.querySelectorAll('.node').forEach(el => el.remove());
            // Очистка связей
            while (svgLayer.firstChild) svgLayer.removeChild(svgLayer.firstChild);

            nodes.forEach(n => renderNodeDOM(n));
            edges.forEach(e => renderEdgeDOM(e));
        }

        function renderNodeDOM(node) {
            const el = document.createElement('div');
            el.className = `node type-${node.type} color-${node.color || 'default'} shape-${node.shape || 'default'}`;
            el.id = node.id;
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';
            if (node.width) el.style.width = node.width + 'px';

            let contentHtml = '';
            if (node.type === 'text' || node.type === 'link') {
                contentHtml = `<div class="node-content" contenteditable="true" onblur="updateContent('${node.id}', this)">${node.content}</div>`;
            } else if (node.type === 'task') {
                contentHtml = `<div class="node-content">${node.content} <div class="task-add" onclick="addTaskRow('${node.id}', this)">+ Add Item</div></div>`;
            } else if (node.type === 'image') {
                contentHtml = `<div class="node-media">${node.content}</div>`;
            }

            el.innerHTML = `
                <div class="node-header" onmousedown="startNodeDrag(event, '${node.id}')">
                    <span class="node-title" contenteditable="true" onblur="updateTitle('${node.id}', this)">${node.title}</span>
                </div>
                ${contentHtml}
                <div class="resizer" onmousedown="startResize(event, '${node.id}')"></div>
                <!-- Точки подключения -->
                <div class="handle h-top" data-side="top" onmousedown="startConnect(event, '${node.id}', 'top')"></div>
                <div class="handle h-right" data-side="right" onmousedown="startConnect(event, '${node.id}', 'right')"></div>
                <div class="handle h-bottom" data-side="bottom" onmousedown="startConnect(event, '${node.id}', 'bottom')"></div>
                <div class="handle h-left" data-side="left" onmousedown="startConnect(event, '${node.id}', 'left')"></div>
            `;
            
            // Клик для выделения
            el.addEventListener('mousedown', (e) => {
                if(!e.target.classList.contains('handle')) selectNode(node.id);
            });

            world.appendChild(el);
        }

        function renderEdgeDOM(edge) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.classList.add("connection");
            path.id = edge.id;
            path.addEventListener('click', (e) => { 
                if(confirm('Delete connection?')) {
                    edges = edges.filter(ed => ed.id !== edge.id);
                    renderAll(); saveData();
                }
            });
            svgLayer.appendChild(path);
            updateEdgePath(edge);
        }

        function updateEdgePath(edge) {
            const el = document.getElementById(edge.id);
            if (!el) return;
            const p1 = getHandlePos(edge.from, edge.sideFrom);
            const p2 = getHandlePos(edge.to, edge.sideTo);
            
            // Кривая Безье
            const dx = Math.abs(p1.x - p2.x) * 0.5;
            let c1x = p1.x, c1y = p1.y, c2x = p2.x, c2y = p2.y;
            
            if(edge.sideFrom === 'top') c1y -= dx; else if(edge.sideFrom === 'bottom') c1y += dx; else if(edge.sideFrom === 'left') c1x -= dx; else c1x += dx;
            if(edge.sideTo === 'top') c2y -= dx; else if(edge.sideTo === 'bottom') c2y += dx; else if(edge.sideTo === 'left') c2x -= dx; else c2x += dx;

            el.setAttribute("d", `M ${p1.x} ${p1.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`);
        }

        function getHandlePos(nodeId, side) {
            const el = document.getElementById(nodeId);
            if (!el) return {x:0, y:0};
            const r = { x: parseFloat(el.style.left), y: parseFloat(el.style.top), w: el.offsetWidth, h: el.offsetHeight };
            if (side === 'top') return { x: r.x + r.w/2, y: r.y };
            if (side === 'bottom') return { x: r.x + r.w/2, y: r.y + r.h };
            if (side === 'left') return { x: r.x, y: r.y + r.h/2 };
            return { x: r.x + r.w, y: r.y + r.h/2 };
        }

        // --- INTERACTION ---
        let dragMode = null; // 'pan', 'node', 'resize', 'connect'
        let activeObj = null;
        let tempLine = null;

        function getWorldPos(e) {
            return {
                x: (e.clientX - state.panX) / state.scale,
                y: (e.clientY - state.panY) / state.scale
            };
        }

        function onPointerDown(e) {
            if (e.target === viewport || e.target === world || e.target.id === 'grid-bg') {
                dragMode = 'pan';
                state.startX = e.clientX;
                state.startY = e.clientY;
                viewport.style.cursor = 'grabbing';
                deselectNode();
            }
        }

        function startNodeDrag(e, id) {
            if (e.target.isContentEditable) return;
            e.stopPropagation();
            dragMode = 'node';
            activeObj = { id, offset: getWorldPos(e) };
            const n = nodes.find(x => x.id === id);
            activeObj.initX = n.x; activeObj.initY = n.y;
            selectNode(id);
        }

        function startResize(e, id) {
            e.stopPropagation();
            dragMode = 'resize';
            activeObj = { id, startX: e.clientX };
            const n = nodes.find(x => x.id === id);
            activeObj.startW = n.width || 240;
        }

        function startConnect(e, id, side) {
            e.stopPropagation();
            dragMode = 'connect';
            activeObj = { id, side };
            tempLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
            tempLine.setAttribute("class", "connection");
            tempLine.style.pointerEvents = "none";
            svgLayer.appendChild(tempLine);
        }

        function onPointerMove(e) {
            if (!dragMode) return;

            if (dragMode === 'pan') {
                const dx = e.clientX - state.startX;
                const dy = e.clientY - state.startY;
                state.panX += dx; state.panY += dy;
                state.startX = e.clientX; state.startY = e.clientY;
                updateTransform();
            } else if (dragMode === 'node') {
                const wp = getWorldPos(e);
                const n = nodes.find(x => x.id === activeObj.id);
                n.x = activeObj.initX + (wp.x - activeObj.offset.x);
                n.y = activeObj.initY + (wp.y - activeObj.offset.y);
                const el = document.getElementById(n.id);
                el.style.left = n.x + 'px'; el.style.top = n.y + 'px';
                updateContextMenuPos();
                edges.filter(ed => ed.from === n.id || ed.to === n.id).forEach(updateEdgePath);
            } else if (dragMode === 'resize') {
                const dx = (e.clientX - activeObj.startX) / state.scale;
                const n = nodes.find(x => x.id === activeObj.id);
                n.width = Math.max(150, activeObj.startW + dx);
                document.getElementById(n.id).style.width = n.width + 'px';
                updateContextMenuPos();
                edges.filter(ed => ed.from === n.id || ed.to === n.id).forEach(updateEdgePath);
            } else if (dragMode === 'connect') {
                const wp = getWorldPos(e);
                const p1 = getHandlePos(activeObj.id, activeObj.side);
                const d = `M ${p1.x} ${p1.y} L ${wp.x} ${wp.y}`;
                tempLine.setAttribute("d", d);
            }
        }

        function onPointerUp(e) {
            if (dragMode === 'connect') {
                const target = document.elementFromPoint(e.clientX, e.clientY);
                if (target && target.classList.contains('handle')) {
                    const targetNode = target.closest('.node');
                    const sideTo = target.getAttribute('data-side');
                    if (targetNode.id !== activeObj.id) {
                        edges.push({
                            id: 'e' + Date.now(),
                            from: activeObj.id, sideFrom: activeObj.side,
                            to: targetNode.id, sideTo: sideTo
                        });
                        renderAll();
                    }
                }
                tempLine.remove();
            }
            if (dragMode) saveData();
            dragMode = null;
            viewport.style.cursor = 'grab';
        }

        function onWheel(e) {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const delta = -Math.sign(e.deltaY) * zoomIntensity;
                const oldScale = state.scale;
                let newScale = state.scale * (1 + delta);
                newScale = Math.min(Math.max(0.2, newScale), 5); // Limits

                // Zoom towards mouse
                const rect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate position relative to world
                const worldX = (mouseX - state.panX) / oldScale;
                const worldY = (mouseY - state.panY) / oldScale;

                state.panX = mouseX - worldX * newScale;
                state.panY = mouseY - worldY * newScale;
                state.scale = newScale;
                
                updateTransform();
            }
        }

        function updateTransform() {
            world.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
            // Сетку двигаем через background-position, чтобы создать эффект бесконечности, но масштаб применяем визуально
            const bg = document.getElementById('grid-bg');
            // Хак: мы просто делаем grid-bg огромным и фиксированным внутри world, это проще всего
        }

        // --- NODE LOGIC ---
        function spawnNode(type) {
            const center = { x: -state.panX/state.scale + window.innerWidth/2/state.scale, y: -state.panY/state.scale + window.innerHeight/2/state.scale };
            if (type === 'text') createNode(center.x, center.y, 'text', 'Note', 'New text node');
            if (type === 'task') createNode(center.x, center.y, 'task', 'To-Do', getTaskHtml());
            if (type === 'link') openModal('Add Link', 'Enter URL:', (val) => createNode(center.x, center.y, 'link', 'Link', `<a href="${val}" target="_blank">${val}</a>`));
        }
        
        function createNode(x, y, type, title, content) {
            const newNode = {
                id: 'n' + (idCounter++),
                x: x - 100, y: y - 50,
                type, title, content,
                width: type==='image'? 300 : 240
            };
            nodes.push(newNode);
            renderAll();
            saveData();
        }

        function updateTitle(id, el) {
            const n = nodes.find(x => x.id === id);
            if(n) { n.title = el.innerText; saveData(); }
        }
        function updateContent(id, el) {
            const n = nodes.find(x => x.id === id);
            if(n) { n.content = el.innerHTML; saveData(); }
        }
        
        // Task Helpers
        function getTaskHtml() {
            return `<div class="task-row"><div class="task-check" onclick="toggleTask(this)"></div><input type="text" class="task-input" value="Task 1" oninput="saveNodeHtml(this)"></div>`;
        }
        window.addTaskRow = function(id, btn) {
            const div = document.createElement('div');
            div.className = 'task-row';
            div.innerHTML = `<div class="task-check" onclick="toggleTask(this)"></div><input type="text" class="task-input" placeholder="New task..." oninput="saveNodeHtml(this)">`;
            btn.before(div);
            saveNodeHtml(btn);
        };
        window.toggleTask = function(el) {
            el.parentNode.classList.toggle('done');
            saveNodeHtml(el);
        };
        window.saveNodeHtml = function(el) {
            const nodeEl = el.closest('.node');
            const contentDiv = nodeEl.querySelector('.node-content');
            // Переносим value инпутов в атрибуты для сохранения
            contentDiv.querySelectorAll('input').forEach(i => i.setAttribute('value', i.value));
            const n = nodes.find(x => x.id === nodeEl.id);
            if(n) { n.content = contentDiv.innerHTML; saveData(); }
        }

        // --- SELECTION & STYLES ---
        function selectNode(id) {
            selectedNodeId = id;
            document.querySelectorAll('.node').forEach(el => el.classList.remove('selected'));
            const el = document.getElementById(id);
            if(el) {
                el.classList.add('selected');
                updateContextMenuPos();
            }
        }
        
        function deselectNode() {
            selectedNodeId = null;
            document.querySelectorAll('.node').forEach(el => el.classList.remove('selected'));
            contextMenu.style.display = 'none';
        }

        function updateContextMenuPos() {
            if(!selectedNodeId) return;
            const el = document.getElementById(selectedNodeId);
            const rect = el.getBoundingClientRect();
            contextMenu.style.display = 'flex';
            contextMenu.style.left = (rect.left + rect.width/2 - contextMenu.offsetWidth/2) + 'px';
            contextMenu.style.top = (rect.top - 50) + 'px';
        }

        function applyStyle(prop, val) {
            if(!selectedNodeId) return;
            const n = nodes.find(x => x.id === selectedNodeId);
            n[prop] = val;
            renderAll();
            selectNode(selectedNodeId);
            saveData();
        }

        function deleteSelectedNode() {
            if(!selectedNodeId) return;
            nodes = nodes.filter(n => n.id !== selectedNodeId);
            edges = edges.filter(e => e.from !== selectedNodeId && e.to !== selectedNodeId);
            deselectNode();
            renderAll();
            saveData();
        }
        
        function confirmClearCanvas() {
            if(confirm('Clear current canvas?')) {
                nodes = []; edges = [];
                renderAll(); saveData();
            }
        }

        // --- MEDIA & FILES ---
        function openMediaModal(type) {
            openModal('Add Image', 'Enter Image URL:', (val) => {
                const center = { x: -state.panX/state.scale + window.innerWidth/2/state.scale, y: -state.panY/state.scale + window.innerHeight/2/state.scale };
                createNode(center.x, center.y, 'image', 'Image', `<img src="${val}">`);
            });
            // Add upload btn logic if needed
        }

        // --- UI HELPERS ---
        function renderSidebar() {
            const list = document.getElementById('space-list');
            list.innerHTML = '';
            spaces.forEach(s => {
                const div = document.createElement('div');
                div.className = `space-item ${s === currentSpace ? 'active' : ''}`;
                div.innerHTML = `<span onclick="loadSpace('${s}')">${s}</span> <span class="space-del" onclick="deleteSpace('${s}')">×</span>`;
                list.appendChild(div);
            });
        }
        
        function openCreateSpaceModal() {
            openModal('New Space', 'Name:', (val) => {
                if(val && !spaces.includes(val)) {
                    spaces.push(val); localStorage.setItem('lc_spaces', JSON.stringify(spaces));
                    loadSpace(val);
                }
            });
        }
        
        function deleteSpace(name) {
            if(spaces.length <= 1) return alert('Cannot delete last space');
            if(confirm(`Delete "${name}"?`)) {
                spaces = spaces.filter(s => s !== name);
                localStorage.setItem('lc_spaces', JSON.stringify(spaces));
                localStorage.removeItem(`lc_data_${name}`);
                loadSpace(spaces[0]);
            }
        }

        // Modal Logic
        const modal = document.getElementById('modal-overlay');
        let onModalConfirm = null;
        function openModal(title, placeholder, cb) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-body').innerHTML = `<input class="modal-input" id="modal-inp" placeholder="${placeholder}">`;
            onModalConfirm = cb;
            modal.style.display = 'flex';
            setTimeout(()=>document.getElementById('modal-inp').focus(), 100);
        }
        document.getElementById('modal-confirm-btn').onclick = () => {
            const val = document.getElementById('modal-inp').value;
            if(val && onModalConfirm) onModalConfirm(val);
            closeModal();
        };
        function closeModal() { modal.style.display = 'none'; onModalConfirm = null; }

        // Backup
        function downloadBackup() {
            saveData();
            const allData = {};
            Object.keys(localStorage).forEach(k => { if(k.startsWith('lc_')) allData[k] = localStorage.getItem(k); });
            const blob = new Blob([JSON.stringify(allData)], {type: 'application/json'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
            a.download = 'liquid-canvas-backup.json'; a.click();
        }
        function triggerRestore() { fileInput.click(); }
        fileInput.onchange = (e) => {
            const f = e.target.files[0];
            if(!f) return;
            const r = new FileReader();
            r.onload = (ev) => {
                try {
                    const d = JSON.parse(ev.target.result);
                    Object.keys(d).forEach(k => localStorage.setItem(k, d[k]));
                    location.reload();
                } catch(err) { alert('Invalid file'); }
            };
            r.readAsText(f);
        }

        // START
        init();
    </script>
</body>
</html>
